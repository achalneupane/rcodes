## try http:// if https:// URLs are not supported
# BiocManager::install("edgeR") # Installing
library("edgeR") # Loading installed edgeR libraries


## Ensemble GTF can be extracted 
#gunzip Homo_sapiens.GRCh38.99.gtf.gz

# sed '/^[[:blank:]]*#/d;s/#.*//' Homo_sapiens.GRCh38.99.gtf | awk '($3 == "gene")' | awk -F";" '$1=$1' OFS="\t" > Homo_sapiens.GRCh38.87_gene_annotation.txt 


mydesign <- read.table("https://raw.githubusercontent.com/achalneupane/data/master/exp_design.csv", header=T, sep=",")
x <- read.table("https://raw.githubusercontent.com/achalneupane/data/master/hg38_counts.matrix", header=T, sep="\t", row.names=1)
# get rid of rows with zero values
x <- x[apply(x, 1, function(x) !all(x==0)),]

dbs <- read.table("https://raw.githubusercontent.com/achalneupane/data/master/Homo_sapiens.GRCh38.87_gene_annotation.txt", header=FALSE, sep="\t")
head(dbs)
dbs <- dbs[,c(9, 11, 13)]
dbs <- sapply(dbs, function(x){gsub("gene_id|gene_name|gene_biotype| ", "", x)})
colnames(dbs) <- c("Geneid", "Gene", "Class")
outpath <- "/media/owner/36bc7216-7321-48cc-b3f4-18f05a9fe11c/RNA-seq_bio792/"



# Check if the above variables are created properly by using 'ls()'. Next check
# the contents of the variables just by typing the variables names you created
# above (if the variable has huge data, do not print everything instead you can
# just print first ten entries using head).

 ls()
 mydesign
 head(x)
 head(dbs, 10)
 outpath

# Give information about the groups to edgeR along with loaded counts matrix.

 group <- factor(mydesign$condition)
 d <- DGEList(counts=x, group=group)

# # Normalizing reads to counts per million (CPM) and filtering the genes by
# # keeping only the genes with CPM > 5 in atleast one sample (prominantly
# # expressed in atleast one sample). We should be carefull in choosing this
# # because if you are analyzing for non-coding RNAs, this value (cpm>5) is too
# # high. Since our aim in this exercise is to get only top significantly
# # expressed protein-coding genes, we are using more stringent criteria.
# 
# 
 dim(d)
 keep <- rowSums(cpm(d)>5) >= 1
 d <- d[keep,]
 dim(d)
 d$samples$lib.size <- colSums(d$counts)

# Dispersion estimates between samples (even within group) and between groups.
# This estimate is important for edgeR to calculate the differential expression
# because it gives information about how close or how variable the samples or
# groups.
 
 # Calculate normalization factors to scale the raw library sizes.


 d <- calcNormFactors(d)
 d1 <- estimateCommonDisp(d, verbose=T)
 d1 <- estimateTagwiseDisp(d1)

## Plotting correlation of samples with normalized counts
 
 # install.packages("pheatmap")
 library(pheatmap)
 # png(paste0(outpath,"sample_correlation.png"))
 pheatmap(cor(log2(cpm(d)+1)), main="SampleCorrelation")
 # dev.off()

# Plotting library sizes of samples (Total number of sequenced reads assigned to
# all genes from the GTF file)

 # png(paste0(outpath,"sample_librarySizes.png"))
 barplot(d$samples$lib.size,las=2,names=colnames(d),cex.names=0.6,horiz=T,main="LibrarySizes")
 # dev.off()

# Differential expression between WT and DEANR1. Exact Tests for Differences
# between Two Groups of Negative-Binomial Counts
 
 et <- exactTest(d1, pair=c("control","DEANR1")) # Testing for differential expression between groups
 res <- topTags(et, 100) # Extracting differentially expressed genes (if you just specify, topTags(et) will give you first ten DEGs)
 res.all <- topTags(et, dim(et)[1]) 
 res$table[,"Geneid"] <- rownames(res$table) # making rownames of the results to be first column of the results with column name 'Geneid' (easy for saving) 
 colnames(res$table) # Checking the columns of results
 resF <- res$table[,c("Geneid","logFC","logCPM","PValue","FDR")]  # Storing selective columns to a variable 'resF'

# Annotating significant genes. We are now ready to merge our 'dbs' with
# information from GTF and DE results. The resulting table will have all
# information about genes from GTF with staus of differential expression
# (statistics generated by edgeR).

 res.all.df <- as.data.frame(res.all)
 res.all.df$Geneid <- rownames(res.all.df)
 resdata <- as.data.frame(res.all)

 # annotated <- merge( dbs, resF, by='Geneid')
 annotated <- merge( dbs, res.all.df, by='Geneid')
# Saving DE results 
# Saving complete DE analysis without any filtering. Usually
# the DE analysis is filtered based on 'FDR' and 'logFC' cutoff.


 write.table(annotated,paste0(outpath,"DEANR1_DEGs_annotated.txt"), sep="\t", quote=F,row.names=F)

## Saving normalized read counts (counts per million) for all samples


 nc <- cpm(d1$counts, normalized.lib.sizes=FALSE) # Normalization
 nc <- cbind(rownames(nc),nc) # converting rownames ('Geneid') into first column of 'nc', it will be useful for annotation.
 colnames(nc)[1] <- "Geneid" # Naming the first column as 'Geneid'
 nc_annotated <- merge( dbs, nc, by='Geneid') # Merging 'dbs' and 'nc' by matching column 'Geneid' 
 write.table(nc_annotated,paste0(outpath,"normalized_cpm.txt"), sep="\t", quote=F,row.names=FALSE)

# Filtering significant gene list. Now we try to filter the differentially
# expressed genes using log2fold change >= 1 and FDR<=0.05. In case of log2fold
# change we also need to get negative fold change values (downregulated genes).
# To achieve this we are going to tell R to convert the values in column
# 'annotated$logFC' to absolute values (abs) and then filter the genes having
# >=1 absolute log2fold change. In this way you will get all up- and
# downregulated genes. Note: In simple term absolute value means converting all
# values to positive, abs(-1)=1 and abs(+1)=1. # Filtered with log-fold change
# >=1 and FDR < 0.05 (all classes of genes and transcripts)


annotated_filt <- subset(annotated,abs(annotated$logFC)>=4 & annotated$FDR<=0.05)
write.table(annotated_filt,paste0(outpath,"DEANR1_DEGs_annotated_filtered_all.txt"), sep="\t", quote=F,row.names=F)

# Filtered with log-fold change >=1 amd FDR < 0.05 (only protein coding)


annotated_filt_pc <- subset(annotated,abs(annotated$logFC)>=4 & annotated$FDR<=0.05 & annotated$Class=="protein_coding")
write.table(annotated_filt_pc,paste0(outpath,"DEANR1_DEGs_annotated_filtered_Protein_Coding.txt"), sep="\t", quote=F,row.names=F)

# Differential Expression summary

summary(annotated_filt$Class)



# The default p-value adjustment method for both of them is Benjamini-Hochberg,
# which is labeled as "FDR" in edgeR and "padj" in DESeq2.



## Volcano plot with "significant" genes labeled
volcanoplot <- function (res, lfcthresh=4, sigthresh=0.05, main="", legendpos="topleft", labelsig=FALSE, textcx=1, ...) {
        with(res, plot(logFC, -log10(PValue), pch=20, main=main, ...))
        with(subset(res, FDR<sigthresh ), points(logFC, -log10(PValue), pch=20, col="red", ...))
        with(subset(res, abs(logFC)>lfcthresh), points(logFC, -log10(PValue), pch=20, col="orange", ...))
        with(subset(res, FDR<sigthresh & abs(logFC)>lfcthresh), points(logFC, -log10(PValue), pch=20, col="blue", ...))
        if (labelsig) {
                require(calibrate)
                with(subset(res, FDR<sigthresh & abs(logFC)>lfcthresh), textxy(logFC, -log10(PValue), labs=Gene, cex=textcx, ...))
        }
        legend(legendpos, xjust=1, yjust=1, legend=c(paste("FDR<",sigthresh,sep=""), paste("|LogFC|>",lfcthresh,sep=""), "both"), pch=20, col=c("red","orange","blue"))
}
# png("4diffexpr-volcanoplot.png", 2000, 1600, pointsize=50)
volcanoplot(resdata, lfcthresh=4, sigthresh=0.05, textcx=.2, xlim=c(-10.3, 10))
# dev.off()

############################################################################
##### We can do the same analysis using DeseQ2
library(DESeq2)
(condition <- factor(c(rep("control", 2), rep("DEANR1", 2), rep("FOXA2", 2))))
# condition <- mydesign
countdata <- as.matrix(x)
(coldata <- data.frame(row.names=colnames(countdata), condition))
dds <- DESeqDataSetFromMatrix(countData=countdata, colData=coldata, design=~condition)
dds

# Run the DESeq pipeline
dds <- DESeq(dds)

# Plot dispersions
# png("qc-dispersions.png", 2000, 2000, pointsize=50)
plotDispEsts(dds, main="")
# dev.off()

# Regularized log transformation for clustering/heatmaps, etc
rld <- rlogTransformation(dds)
head(assay(rld))
hist(assay(rld))

# Colors for plots below
## Ugly:
## (mycols <- 1:length(unique(condition)))
## Use RColorBrewer, better
library(RColorBrewer)
(mycols <- brewer.pal(8, "Dark2")[1:length(unique(condition))])

# Sample distance heatmap
sampleDists <- as.matrix(dist(t(assay(rld))))

# BiocManager::install("gplots")
library(gplots)
# png("qc-heatmap-samples.png", w=2000, h=2000, pointsize=50)
heatmap.2(as.matrix(sampleDists), key=F, trace="none",
          col=colorpanel(100, "black", "white"),
          ColSideColors=mycols[condition], RowSideColors=mycols[condition],
          margin=c(10, 10), main="Sample Distance Matrix")
# dev.off()

rld_pca <- function (rld, intgroup = "condition", ntop = 500, colors=NULL, legendpos="bottomleft", main="PCA Biplot", textcx=1, ...) {
        require(genefilter)
        # BiocManager::install("calibrate")
        require(calibrate)
        require(RColorBrewer)
        rv = rowVars(assay(rld))
        select = order(rv, decreasing = TRUE)[seq_len(min(ntop, length(rv)))]
        pca = prcomp(t(assay(rld)[select, ]))
        fac = factor(apply(as.data.frame(colData(rld)[, intgroup, drop = FALSE]), 1, paste, collapse = " : "))
        if (is.null(colors)) {
                if (nlevels(fac) >= 3) {
                        colors = brewer.pal(nlevels(fac), "Paired")
                } else {
                        colors = c("black", "red")
                }
        }
        pc1var <- round(summary(pca)$importance[2,1]*100, digits=1)
        pc2var <- round(summary(pca)$importance[2,2]*100, digits=1)
        pc1lab <- paste0("PC1 (",as.character(pc1var),"%)")
        pc2lab <- paste0("PC1 (",as.character(pc2var),"%)")
        plot(PC2~PC1, data=as.data.frame(pca$x), bg=colors[fac], pch=21, xlab=pc1lab, ylab=pc2lab, main=main, ...)
        with(as.data.frame(pca$x), textxy(PC1, PC2, labs=rownames(as.data.frame(pca$x)), cex=textcx))
        legend(legendpos, legend=levels(fac), col=colors, pch=20)
        # rldyplot(PC2 ~ PC1, groups = fac, data = as.data.frame(pca$rld),
        # pch = 16, cerld = 2, aspect = "iso", col = colours, main = draw.key(key = list(rect = list(col = colours),
        # terldt = list(levels(fac)), rep = FALSE)))
}
# png("qc-pca.png", 2000, 2000, pointsize=50)
rld_pca(rld, colors=mycols, intgroup="condition", xlim=c(-75, 65), ylim = c(-10,10))
# dev.off()


# Get differential expression results
res = results(dds, contrast=c("condition","DEANR1","control"))
# res = results(dds, contrast=c("condition","FOXA2","control"))
# res <- results(dds)
table(res$padj<0.05)
## Order by adjusted p-value
res <- res[order(res$padj), ]
## Merge with normalized count data
resdata <- merge(as.data.frame(res), as.data.frame(counts(dds, normalized=TRUE)), by="row.names", sort=FALSE)
names(resdata)[1] <- "Geneid"
head(resdata)
## Write results
write.table(resdata, file="diffexpr-results.csv", quote = FALSE, sep = "\t", col.names = TRUE, row.names = FALSE)

## Examine plot of p-values
hist(res$pvalue, breaks=50, col="grey")


## MA plot
maplot <- function (resdata, thresh=0.05, labelsig=FALSE, textcx=1, ...) {
        with(resdata, plot(baseMean, log2FoldChange, pch=20, cex=.5, log="x", ...))
        abline(h=4, col="blue", lty=2)
        abline(h=-4, col="blue", lty=2)
        with(subset(resdata, padj<thresh), points(baseMean, log2FoldChange, col="red", pch=20, cex=1.5))
        legend( "topleft", c("Not-Sig", "Sig" ), text.col=c("black", "red"), pch = 20, col = c("black", "red"), title = "", cex=1.3, pt.cex = 2 )
        if (labelsig) {
                require(calibrate)
                with(subset(resdata, padj<thresh), textxy(baseMean, log2FoldChange, labs=Gene, cex=textcx, col=2))
                
        }
}

# resdata$log2FoldChange <- as.numeric(resdata$log2FoldChange)
max(resdata$log2FoldChange)


# png("diffexpr-maplot.png", 1500, 1000, pointsize=5)
maplot(resdata, main="")
# dev.off()

# # The base mean is the mean of normalized counts of all samples, normalizing for
# # sequencing depth. It does not take into account gene length. The base mean is
# # used in DESeq2 only for estimating the dispersion of a gene (it is used to
# # estimate the fitted dispersion).
# 


## Volcano plot with "significant" genes labeled
volcanoplot <- function (res, lfcthresh=4, sigthresh=0.05, main="", legendpos="topleft", labelsig=FALSE, textcx=1, ...) {
        with(res, plot(log2FoldChange, -log10(pvalue), pch=20, main=main, ...))
        with(subset(res, padj<sigthresh ), points(log2FoldChange, -log10(pvalue), pch=20, col="red", ...))
        with(subset(res, abs(log2FoldChange)>lfcthresh), points(log2FoldChange, -log10(pvalue), pch=20, col="orange", ...))
        with(subset(res, padj<sigthresh & abs(log2FoldChange)>lfcthresh), points(log2FoldChange, -log10(pvalue), pch=20, col="blue", ...))
        if (labelsig) {
                require(calibrate)
                with(subset(res, padj<sigthresh & abs(log2FoldChange)>lfcthresh), textxy(log2FoldChange, -log10(pvalue), labs=Gene, cex=textcx, ...))
        }
        legend(legendpos, xjust=1, yjust=1, legend=c(paste("FDR<",sigthresh,sep=""), paste("|LogFC|>",lfcthresh,sep=""), "both"), pch=20, col=c("red","orange","blue"))
}
# png("4diffexpr-volcanoplot.png", 2000, 1600, pointsize=50)
volcanoplot(resdata, lfcthresh=4, sigthresh=0.05, textcx=.2, xlim=c(-10.3, 10))
# dev.off()


# ggplot
volcano.res <- res
volcano.res <- as.data.frame(volcano.res)
threshold_OE <- res$padj < 0.05
# ## Determine the number of TRUE values
# length(which(threshold_OE))
# ## Add logical vector as a column (threshold) to the res_tableOE
# volcano.res$threshold <- threshold_OE 
# 
# ggplot(volcano.res) +
#   geom_point(aes(x=log2FoldChange, y=-log10(padj), colour=threshold)) +
#   ggtitle("Mov10 overexpression") +
#   xlab("log2 fold change") + 
#   ylab("-log10 adjusted p-value") +
#   #scale_y_continuous(limits = c(0,50)) +
#   theme(legend.position = "none",
#         plot.title = element_text(size = rel(1.5), hjust = 0.5),
#         axis.title = element_text(size = rel(1.25)))
# 
# 
# # This is a great way to get an overall picture of what is going on, but what if
# # we also wanted to know where the top 10 genes (lowest padj) in our DE list are
# # located on this plot? We could label those dots with the gene name on the
# # Volcano plot using geom_text_repel().
# 
# # To make this work we have to take the following 3 steps: (Step 1) Create a new
# # data frame sorted or ordered by padj (Step 2) Indicate in the data frame which
# # genes we want to label by adding a logical vector to it, wherein “TRUE” =
# # genes we want to label.
# 
## Sort by ordered padj
res_tableOE <- resdata
res_tableOE <- merge( dbs, res_tableOE, by='Geneid')
res_tableOE_ordered <- res_tableOE[order(res_tableOE$padj), ]
View(res_tableOE_ordered)


# 4 logfold
highly_significant_high_expression <- subset(res_tableOE_ordered,abs(res_tableOE_ordered$log2FoldChange)>=4 & res_tableOE_ordered$padj<=0.05)
# highly_significant_high_expression <- res_tableOE_ordered[(res_tableOE_ordered$padj < 0.05) & (res_tableOE_ordered$log2FoldChange > 4 | res_tableOE_ordered$log2FoldChange < -4),]
highly_significant_high_expression <- highly_significant_high_expression[highly_significant_high_expression$Class =="protein_coding",]
write.table(highly_significant_high_expression, paste0(outpath,"DESeq_protein_coding_4Logfold_diffexpr-results_highly_significant_high_expression.csv"), quote = FALSE, sep = "\t", col.names = TRUE, row.names = FALSE)

dim(highly_significant_high_expression)
dim(annotated_filt)

# common
sum(annotated_filt$Geneid %in% highly_significant_high_expression$Geneid)

all <- merge(annotated_filt, highly_significant_high_expression, by.x="Geneid", by.y="Geneid", all = TRUE)
write.table(all, paste0(outpath,"DESEQ_EDGER_log4.csv"), quote = FALSE, sep = "\t", col.names = TRUE, row.names = FALSE)

# More readings:

# DESeq and EdgeR are very similar and both assume that no genes are
# differentially expressed. DEseq uses a "geometric" normalisation strategy,
# whereas EdgeR is a weighted mean of log ratios-based method. Both normalise
# data initially via the calculation of size / normalisation factors.

# Limma is different in that it normalises via the very successful (for
# microarrays) quantile nomalisation, where an attempt is made to match gene
# count distributions across samples in your dataset. It can somewhat loosely be
# viewed as scaling each sample's values to be between the min and max values
# (across all samples). Thus, the final distributions will be similar.

# Here is further information (important parts in bold):

# DESeq2 DESeq: This normalization method [14] is included in the DESeq
# Bioconductor package (version 1.6.0) [14] and is based on the hypothesis that
# most genes are not DE. A DESeq scaling factor for a given lane is computed as
# the median of the ratio, for each gene, of its read count over its geometric
# mean across all lanes. The underlying idea is that non-DE genes should have
# similar read counts across samples, leading to a ratio of 1. Assuming most
# genes are not DE, the median of this ratio for the lane provides an estimate
# of the correction factor that should be applied to all read counts of this
# lane to fulfill the hypothesis. By calling the estimateSizeFactors() and
# sizeFactors() functions in the DESeq Bioconductor package, this factor is
# computed for each lane, and raw read counts are divided by the factor
# associated with their sequencing lane.

# [source: https://www.ncbi.nlm.nih.gov/pubmed/22988256]

# EdgeR: 
# Trimmed Mean of M-values (TMM): This normalization method [17] is
# implemented in the edgeR Bioconductor package (version 2.4.0). It is also
# based on the hypothesis that most genes are not DE. The TMM factor is computed
# for each lane, with one lane being considered as a reference sample and the
# others as test samples. For each test sample, TMM is computed as the weighted
# mean of log ratios between this test and the reference, after exclusion of the
# most expressed genes and the genes with the largest log ratios. According to
# the hypothesis of low DE, this TMM should be close to 1. If it is not, its
# value provides an estimate of the correction factor that must be applied to
# the library sizes (and not the raw counts) in order to fulfill the hypothesis.
# The calcNormFactors() function in the edgeR Bioconductor package provides
# these scaling factors. To obtain normalized read counts, these normalization
# factors are re-scaled by the mean of the normalized library sizes. Normalized
# read counts are obtained by dividing raw read counts by these re-scaled
# normalization factors.

# [source: https://www.ncbi.nlm.nih.gov/pubmed/22988256]

# Limma:
# Quantile (Q): First proposed in the context of microarray data, this
# normalization method consists in matching distributions of gene counts across
# lanes [22, 23]. It is implemented in the Bioconductor package limma [31] by
# calling the normalizeQuantiles() function.

# https://support.bioconductor.org/p/104162/
